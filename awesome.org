#+Title: My AwesomeWM Configuration
#+Author: J. Dylan White
#+Date: <2022-06-30 Thu>

* To Do

** TODO Break up code blocks into more managable chunks 
** TODO Add GTK themeing
** TODO Add temperatures to wibar
- parse "sensors" output
** DONE Add HDD/SSD space to wibar
CLOSED: [2023-01-17 Tue 20:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-01-17 Tue 20:56]
:END:
** DONE Add memory to wibar
CLOSED: [2023-01-17 Tue 19:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2023-01-17 Tue 19:46]
:END:
- parse "free -m" output
- [[https://www.cyberciti.biz/faq/linux-check-memory-usage/][useful resource]]
** TODO Add CPU usage to wibar
** TODO Add weather/temperature to wibar
** TODO Fix spacing
** TODO Theme hotkeys menu

* Welcome!

This Org-Mode file generates my [[https://awesomewm.org/][Awesome window manager]] configuration files. After edits are made here, the code blocks are automatically gathered and sent to =~/.config/awesome/rc.lua= or some otherwise specified configuration file. The =rc.lua= config is primarily for core functionality, while, for example, a separate =theme.lua= file that is referenced in =rc.lua= is also compiled here in the file.

You can find the default [[https://awesomewm.org/doc/api/sample%20files/rc.lua.html][rc.lua]] and [[https://awesomewm.org/doc/api/sample%20files/theme.lua.html][theme.lua]] files on the AwesomeWM documentation page if you want it.

* Primary Configuration
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/awesome/rc.lua :mkdirp yes 
:END:

This section contains all of the code for the configuration file =~/.config/awesome/rc.lua=.  

First, let's add a note at the top of the file indicating that changes are to be made here in this file, rather than in the config file directly.

#+begin_src lua

  -- NOTE: This file is automatically updated from changes in the file
  -- ~/.dotfiles/awesome.org. If you wish to make changes to this
  -- configuration file, please do so within the awesome.org file!

#+end_src

** Variable Definitions

#+begin_src lua

  local emacs = "emacsclient -c -a 'emacs' "

#+end_src

** Load Libraries

AwesomeWM comes installed with several packages. Let's load what we need here.

#+begin_src lua

  -- If LuaRocks is installed, make sure that packages installed through
  -- it are found (e.g. lgi). If LuaRocks is not installed, do nothing.
  pcall(require, "luarocks.loaderx")

  -- Standard awesome library
  local gears = require("gears")
  local awful = require("awful")
  require("awful.autofocus")

  -- Widget and layout library
  local wibox = require("wibox")

  -- Theme handling library
  local beautiful = require("beautiful")

  -- Notification library
  local naughty = require("naughty")
  local menubar = require("menubar")
  local hotkeys_popup = require("awful.hotkeys_popup")

  -- Enable hotkeys help widget for VIM and other apps
  -- when client with a matching name is opened:
  require("awful.hotkeys_popup.keys")

#+end_src

** Error Handling

If an error prevents the window manager from starting, or if an error occurs later, we need to be notified.

#+begin_src lua

  -- Check if awesome encountered an error during startup and fell
  -- back to another config (This code will only ever execute for
  -- the fallback config)
  if awesome.startup_errors then
     naughty.notify({ preset = naughty.config.presets.critical,
        title = "Oops, there were errors during startup!",
        text = awesome.startup_errors })
  end

  -- Handle runtime errors after startup
  do
     local in_error = false
     awesome.connect_signal("debug::error", function (err)
        -- Make sure we don't go into an endless error loop
        if in_error then return end
        in_error = true

        naughty.notify({ preset = naughty.config.presets.critical,
           title = "Oops, an error happened!",
           text = tostring(err) })
        in_error = false
     end)
  end

#+end_src

** Variable Definitions

Here we declare some useful variables to be used throughout. This is where we specify the theme, mod key, terminal, editor, and layout list.

#+begin_src lua

  -- Themes define colours, icons, font and wallpapers.
  beautiful.init("/home/jdylanwhite/.config/awesome/themes/dracula/theme.lua")

  -- This is used later as the default terminal and editor to run.
  terminal = "alacritty"
  editor = os.getenv("EDITOR") or "emacs"
  editor_cmd = terminal .. " -e " .. editor

  -- Set the default modkey.
  modkey = "Mod4"

  -- Table of layouts to cover with awful.layout.inc, order matters.
  awful.layout.layouts = {
     awful.layout.suit.tile,
     awful.layout.suit.tile.left,
     awful.layout.suit.tile.bottom,
     awful.layout.suit.tile.top,
     awful.layout.suit.fair,
     awful.layout.suit.fair.horizontal,
     awful.layout.suit.spiral,
     awful.layout.suit.spiral.dwindle,
     awful.layout.suit.max,
     awful.layout.suit.max.fullscreen,
     awful.layout.suit.magnifier,
     awful.layout.suit.corner.nw,
     awful.layout.suit.floating,
  }

#+end_src
  
** Create the Menu

The menu is present when you right click somewhere on the desktop. This is useful now as I learn how to use AwesomeWM, but I may get rid of it eventually

#+begin_src lua

  -- Create a launcher widget and a main menu
  myawesomemenu = {
     { "hotkeys", function() hotkeys_popup.show_help(nil, awful.screen.focused()) end },
     { "manual", terminal .. " -e man awesome" },
     { "edit config", editor_cmd .. " " .. awesome.conffile },
     { "restart", awesome.restart },
     { "quit", function() awesome.quit() end },
  }

  -- Build the menu
  mymainmenu = awful.menu({ items = { { "awesome", myawesomemenu, beautiful.awesome_icon },
                                      { "open terminal", terminal }
                                    }
                          })

  -- If desired, add a launcher widget in the 
  -- mylauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                                       -- menu = mymainmenu })

  -- Menubar configuration
  menubar.utils.terminal = terminal -- Set the terminal for applications that require it

  -- If desired, add a keyboard map indicator and switcher
  -- mykeyboardlayout = awful.widget.keyboardlayout()

#+end_src

** Wibar

#+begin_src lua

  -- Create a wibox for each screen and add it
  local taglist_buttons = gears.table.join(
     awful.button({ }, 1, function(t) t:view_only() end),
     awful.button({ modkey }, 1, function(t)
        if client.focus then
           client.focus:move_to_tag(t)
        end
     end),
     awful.button({ }, 3, awful.tag.viewtoggle),
     awful.button({ modkey }, 3, function(t)
        if client.focus then
           client.focus:toggle_tag(t)
        end
     end),
     awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
     awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
  )

  local tasklist_buttons = gears.table.join(
     awful.button({ }, 1, function (c)
        if c == client.focus then
           c.minimized = true
        else
           c:emit_signal(
              "request::activate",
              "tasklist",
              {raise = true}
           )
        end
     end),
     awful.button({ }, 3, function()
        awful.menu.client_list({ theme = { width = 250 } })
     end),
     awful.button({ }, 4, function ()
        awful.client.focus.byidx(1)
     end),
     awful.button({ }, 5, function ()
        awful.client.focus.byidx(-1)
  end))

  local function set_wallpaper(s)
     -- Wallpaper
     if beautiful.wallpaper then
        local wallpaper = beautiful.wallpaper
        -- If wallpaper is a function, call it with the screen
        if type(wallpaper) == "function" then
           wallpaper = wallpaper(s)
        end
        gears.wallpaper.maximized(wallpaper, s, true)
     end
  end

  -- Re-set wallpaper when a screen's geometry changes (e.g. different resolution)
  screen.connect_signal("property::geometry", set_wallpaper)

  awful.screen.connect_for_each_screen(function(s)
     -- Wallpaper
     set_wallpaper(s)

     -- Each screen has its own tag table.
     awful.tag({ " 1 "," 2 "," 3 ", " 4 ", " 5 ", " 6 ", " 7 ", " 8 ", " 9 "}, s, awful.layout.layouts[1])

     -- Create a promptbox for each screen
     s.mypromptbox = awful.widget.prompt()
     -- Create an imagebox widget which will contain an icon indicating which layout we're using.
     -- We need one layoutbox per screen.
     s.mylayoutbox = awful.widget.layoutbox(s)
     s.mylayoutbox:buttons(gears.table.join(
        awful.button({ }, 1, function () awful.layout.inc( 1) end),
        awful.button({ }, 3, function () awful.layout.inc(-1) end),
        awful.button({ }, 4, function () awful.layout.inc( 1) end),
        awful.button({ }, 5, function () awful.layout.inc(-1) end)))
     -- Create a taglist widget
     s.mytaglist = awful.widget.taglist {
        screen  = s,
        filter  = awful.widget.taglist.filter.all,
        buttons = taglist_buttons
     }

     -- Create widget to separate sections
     breakerwidget = wibox.widget{
        markup = "|",
        halign = "center",
        valign = "center",
        color = beautiful.bg_focus,
        widget = wibox.widget.textbox
     }
     
#+end_src

*** Clock

#+begin_src lua

  -- Create a textclock widget
   local mytextclock = wibox.widget.textclock()
   local month_calendar = awful.widget.calendar_popup.month()
   month_calendar:attach(mytextclock, "tr")

#+end_src

*** Battery Icon  

#+begin_src lua

  -- Set the commands to get the state and percentage
  local battery_state_command = "upower -i $(upower -e | grep \'BAT\') | grep -E \"state\""
  local battery_percent_command = "upower -i $(upower -e | grep \'BAT\') | grep -E \"percentage\""

  -- Create the textbox that will be used to print the battery percentage
  -- and initialize it with an empty string
  batterytextwidget = wibox.widget.textbox()
  batterytextwidget:set_text("")

  -- Create the progressbar that will be used to show the battery charge
  -- and initialize with all background colors
  batterybarwidget = awful.widget.progressbar()
  batterybarwidget:set_border_color(beautiful.bg_normal)
  batterybarwidget:set_border_width(1)
  batterybarwidget:set_background_color(beautiful.bg_normal)
  batterybarwidget:set_color(beautiful.bg_urgent)
  batterybarwidget:set_width(45)
  batterybarwidget.margins = {
     top = 3,
     bottom = 3,
     left = 10,
     right = 10
  }

  -- Create a function to fetch and parse battery information
  local function battery_info()

     -- Parse the percent
     f = io.popen(battery_percent_command,"r")
     local percent = string.match(f:read(),'percentage:%s*(%d+)%%')
     f:close()

     -- Set 'batterytextwidget' textbox with the percentage
     batterytext = ' BAT:'..percent..'%'

     -- Parse the state
     f = io.popen(battery_state_command,"r")
     local state = string.match(f:read(),'state:%s*(%w+)')
     f:close()

     -- Add a +/- to indicate charging or discharging
     if state == "charging" then
        batterytext = batterytext.."+"
     elseif state == "discharging" then
        batterytext = batterytext.."-"
     end

     -- Set the text value for the widget
     batterytextwidget:set_markup("<span foreground='" .. beautiful.bg_urgent .. "'>" .. batterytext .. "</span>")

     -- Fill the progress bar and set the border color
     batterybarwidget:set_border_color(beautiful.bg_urgent) 
     batterybarwidget:set_value(percent/100)

  end

  -- Create the timer which will allow to repeat battery status command (every 5 sec)
  batterywidgettimer = timer({timeout=5})

  -- Initialize the timer and execute the function every 5 seconds
  batterywidgettimer:connect_signal("timeout",battery_info)

  -- Start the timer
  battery_info()
  batterywidgettimer:start()

#+end_src

*** Memory

#+begin_src lua

  -- Set the commands to get memory usage
  local avail_memory_command = "free -m | grep \'Mem:\' | awk \'{print $7}\'"
  local total_memory_command = "free -m | grep \'Mem:\' | awk \'{print $2}\'"

  -- Create function to round decimal values
  local function round(num, numDecimalPlaces)
     local mult = 10^(numDecimalPlaces or 0)
     return math.floor(num * mult + 0.5) / mult
  end

  -- Create the textbox that will be used to print the memory percentage
  -- and initialize it with an empty string
  memorytextwidget = wibox.widget.textbox()
  memorytextwidget:set_text("")

  -- Create the progressbar that will be used to show the memory charge
  -- and initialize with all background colors
  memorybarwidget = awful.widget.progressbar()
  memorybarwidget:set_border_color(beautiful.bg_normal)
  memorybarwidget:set_border_width(1)
  memorybarwidget:set_background_color(beautiful.bg_normal)
  memorybarwidget:set_color(beautiful.fg_focus)
  memorybarwidget:set_width(45)
  memorybarwidget.margins = {
     top = 3,
     bottom = 3,
     left = 10,
     right = 10
  }

  -- Create function to fetch and parse system memory usage
  local function memory_usage()

     -- Parse the available memory
     f = io.popen(avail_memory_command,"r")
     availMem = round(tonumber(f:read()/1024),1)
     f:close()

     -- Parse the total memory
     f = io.popen(total_memory_command,"r")
     totalMem = round(tonumber(f:read()/1024),1)
     f:close()

     -- Return the percentage available
     percentMem = math.floor(100-round(100*availMem/totalMem,0))

     -- Set 'memorytextwidget' textbox with the percentage
     memorytextwidget:set_markup("<span foreground='" .. beautiful.fg_focus .. "'> MEM:" .. percentMem .. "%</span>")


     -- Fill the progress bar and set the border color
     memorybarwidget:set_border_color(beautiful.fg_focus)
     memorybarwidget:set_value(percentMem/100)

  end

  -- Create the timer which will allow to repeat memory status command (every 5 sec)
  memorywidgettimer = timer({timeout=5})

  -- Initialize the timer and execute the function every 5 seconds
  memorywidgettimer:connect_signal("timeout",memory_usage  )

  -- Start the timer
  memory_usage()
  memorywidgettimer:start()

#+end_src

*** Disk Usage

#+begin_src lua

  -- Set the commands to get memory usage
  local used_hdd_command = "df -k | grep \'\\hdd\' | awk \'{print $5}\'"
  local used_ssd_command = "df -k | grep \'\\home\' | awk \'{print $5}\'"

  -- Create the textbox that will be used to print the memory percentage
  -- and initialize it with an empty string
  hddtextwidget = wibox.widget.textbox()
  hddtextwidget:set_text("")
  ssdtextwidget = wibox.widget.textbox()
  ssdtextwidget:set_text("")

  -- Create the progressbar that will be used to show the memory charge
  -- and initialize with all background colors
  hddbarwidget = awful.widget.progressbar()
  hddbarwidget:set_border_color(beautiful.bg_normal)
  hddbarwidget:set_border_width(1)
  hddbarwidget:set_background_color(beautiful.bg_normal)
  hddbarwidget:set_color(beautiful.fg_urgent)
  hddbarwidget:set_width(45)
  hddbarwidget.margins = {
     top = 3,
     bottom = 3,
     left = 10,
     right = 3
  }

  -- Create the progressbar that will be used to show the memory charge
  -- and initialize with all background colors
  ssdbarwidget = awful.widget.progressbar()
  ssdbarwidget:set_border_color(beautiful.bg_normal)
  ssdbarwidget:set_border_width(1)
  ssdbarwidget:set_background_color(beautiful.bg_normal)
  ssdbarwidget:set_color(beautiful.fg_urgent)
  ssdbarwidget:set_width(45)
  ssdbarwidget.margins = {
     top = 3,
     bottom = 3,
     left = 10,
     right = 10
  }

  -- Create the timer which will allow to repeat hdd status command (every 5 sec)
  diskwidgettimer = timer({timeout=60})

  -- Create function to fetch and parse disk usage
  local function disk_usage()

     -- Get HDD usage
     f = io.popen(used_hdd_command,"r")
     local used_hdd = f:read()
     f:close()

     -- Get SSD usage
     f = io.popen(used_ssd_command,"r")
     local used_ssd = f:read()
     f:close()

     -- Set drive usage percents
     hddtextwidget:set_markup("<span foreground='" .. beautiful.fg_urgent .. "'> HDD:" .. used_hdd .. "</span>")
     ssdtextwidget:set_markup("<span foreground='" .. beautiful.fg_urgent .. "'> SSD:" .. used_ssd .. "</span>")

     -- Fill the progress bar and set the border color
     hddbarwidget:set_border_color(beautiful.fg_urgent)
     hddbarwidget:set_value(tonumber(string.match(used_hdd,'(%d+)%%'))/100)

     -- Fill the progress bar and set the border color
     ssdbarwidget:set_border_color(beautiful.fg_urgent)
     ssdbarwidget:set_value(tonumber(string.match(used_ssd,'(%d+)%%'))/100)

  end

  -- Initialize the timer and execute the function every 5 seconds
  diskwidgettimer:connect_signal("timeout",disk_usage)

  -- Start the timer
  disk_usage()
  diskwidgettimer:start()
  diskwidgettimer:again()

#+end_src

*** Volume Control

#+begin_src lua

  volumewidget = wibox.widget.textbox()
  volumewidget:set_align("right")

  -- Create the progressbar that will be used to show the volume 
  -- and initialize with all background colors
  volumebarwidget = awful.widget.progressbar()
  volumebarwidget:set_border_color(beautiful.bg_normal)
  volumebarwidget:set_border_width(1)
  volumebarwidget:set_background_color(beautiful.bg_normal)
  volumebarwidget:set_color(beautiful.border_marked)
  volumebarwidget:set_width(45)
  volumebarwidget.margins = {
     top = 3,
     bottom = 3,
     left = 10,
     right = 10
  }

  function update_volume(widget)

     local fd = io.popen("amixer sget Master")
     local status = fd:read("*all")
     fd:close()

     -- Parse the amixer results to get the volume
     local volume = string.match(status, "(%d?%d?%d)%%")

     -- Amixer doesn't work on initial start up, set as zero at first
     if volume == nil or volume == '' then
        volume = '0'
     else
        volume = string.format("% 3d", volume)
        volume = string.gsub(volume, "%s+", "")
     end

     -- Set the volumebar
     volumebarwidget:set_border_color(beautiful.border_marked)
     volumebarwidget:set_value(tonumber(volume)/100)

     -- Parse the amixer results to get the mute/unmute status
     status = string.match(status, "%[(o[^%]]*)%]")

     -- Amixer doesn't work on initial start up, set as zero at first
     if status == nil or status == '' then
        volume = " VOL: ---"
     --- Set volume or indicate that volume is muted
     else
        if string.find(status, "on", 1, true) then
           -- For the volume numbers
           volume = " VOL:" .. volume .. "%"
        else
           -- For the mute button
           volume = " VOL:" .. volume .. "M"
        end
     end
     widget:set_markup("<span foreground='" .. beautiful.border_marked .. "'>" .. volume .. "</span>")

  end

  update_volume(volumewidget)

  mytimer = timer({ timeout = 0.2 })
  mytimer:connect_signal("timeout", function () update_volume(volumewidget) end)
  mytimer:start()

#+end_src

*** Put The Widgets Together

#+begin_src lua

  -- Create the wibox
  s.mywibox = awful.wibar({ position = "top", screen = s, height = 19 })

  -- Add widgets to the wibox
  s.mywibox:setup {
     layout = wibox.layout.align.horizontal,
     { -- Left widgets
        layout = wibox.layout.fixed.horizontal,
        mylauncher,
        s.mytaglist,
        s.mypromptbox,
     },
     s.mytasklist, -- Middle widget
     { -- Right widgets
        layout = wibox.layout.fixed.horizontal,
        mykeyboardlayout,
        wibox.widget.systray(),
        hddtextwidget,
        hddbarwidget,
        ssdtextwidget,
        ssdbarwidget,
        breakerwidget,
        memorytextwidget,
        memorybarwidget,
        breakerwidget,
        volumewidget,
        volumebarwidget,
        breakerwidget,
        batterytextwidget,
        batterybarwidget,
        breakerwidget,
        mytextclock,
        s.mylayoutbox,
     },
  }
  end)

#+end_src

** Bindings

#+begin_src lua

  -- Mouse bindings
  root.buttons(gears.table.join(
     awful.button({ }, 3, function () mymainmenu:toggle() end),
     awful.button({ }, 4, awful.tag.viewnext),
     awful.button({ }, 5, awful.tag.viewprev)
  ))

  -- Key bindings
  globalkeys = gears.table.join(

     -- Raise volume
     awful.key(
        { }, "XF86AudioRaiseVolume",
        function ()
           awful.util.spawn("amixer set Master 5%+", false)
        end
     ),

     -- Lower volume
     awful.key(
        { }, "XF86AudioLowerVolume",
        function ()
           awful.util.spawn("amixer set Master 5%-", false)
        end
     ),

     -- Mute volume
     awful.key(
        { }, "XF86AudioMute",
        function ()
           awful.util.spawn("amixer sset Master toggle", false)
        end
     ),

     -- Show key bindings
     awful.key(
        {modkey,}, "s",
        hotkeys_popup.show_help,
        {
           description="show help",
           group="awesome"
        }
     ),

     -- Go to left tag
     awful.key(
        {modkey,}, "Left",
        awful.tag.viewprev,
        {
           description="view previous",
           group="tag"
        }
     ),

     -- Go to right tag
     awful.key(
        {modkey,}, "Right",
        awful.tag.viewnext,
        {
           description="view next",
           group="tag"
        }
     ),

     -- Return to last tag
     awful.key(
        {modkey,}, "Escape",
        awful.tag.history.restore,
        {
           description="go back", group="tag"
        }
     ),

     -- Move focus to next window
     awful.key(
        {modkey,}, "j",
        function ()
           awful.client.focus.byidx(1)
        end,
        {
           description="focus next by index",
           group="client"
        }
     ),

     -- Move focus to previous window
     awful.key(
        {modkey,}, "k",
        function ()
           awful.client.focus.byidx(-1)
        end,
        {
           description="focus previous by index",
           group="client"
        }
     ),

     -- Show the main menu
     awful.key(
        {modkey,}, "w",
        function ()
           mymainmenu:show()
        end,
        {
           description="show main menu",
           group="awesome"
        }
     ),

     -- Swap current window with the next window
     awful.key(
        {modkey, "Shift"}, "j",
        function ()
           awful.client.swap.byidx(1)
        end,
        {
           description="swap with next client by index",
           group="client"
        }
     ),

     -- Swap current window with the previous window
     awful.key({modkey, "Shift"}, "k",
        function ()
           awful.client.swap.byidx(-1)
        end,
        {
           description="swap with previous client by index",
           group="client"
     }
     ),

     -- Move focus to the next screen
     awful.key(
        {modkey, "Control" }, "j",
        function ()
           awful.screen.focus_relative(1)
        end,
        {
           description="focus the next screen",
           group="screen"
        }
     ),

     -- Move focus to the previous screen
     awful.key(
        {modkey, "Control" }, "k",
        function ()
           awful.screen.focus_relative(-1)
        end,
        {
           description="focus the previous screen",
           group="screen"}
     ),

     -- Move to urgent client
     awful.key({modkey,           }, "u", awful.client.urgent.jumpto,
        {description="jump to urgent client", group="client"}),

     -- Return focus to previous client
     awful.key({modkey,}, "Tab",
        function ()
           awful.client.focus.history.previous()
           if client.focus then
              client.focus:raise()
           end
        end,
        {
           description="go back",
           group="client"
        }
     ),

     -- Standard program
     awful.key(
        {modkey,}, "Return",
        function ()
           awful.spawn(terminal)
        end,
        {
           description="open a terminal",
           group="launcher"
        }
     ),

     -- Open a browser
     awful.key(
        {modkey,}, "b",
        function ()
          awful.spawn("firefox")
        end,
        {
            description="open a browser",
            group="launcher"
         }
     ),

     -- Restart awesome session
     awful.key(
        {modkey, "Control"}, "r",
        awesome.restart,
        {
           description="reload awesome",
           group="awesome"
        }
     ),

     -- Quit awesome session
     awful.key(
        {modkey, "Shift"}, "q",
        awesome.quit,
        {
           description="quit awesome",
           group="awesome"
        }
     ),

     -- Shift left/right split to the right
     awful.key(
        {modkey,}, "l",
        function ()
           awful.tag.incmwfact(0.05)
        end,
        {
           description="increase master width factor",
           group="layout"
        }
     ),

     -- Shift left/right split to the left
     awful.key(
        {modkey,}, "h",
        function ()
           awful.tag.incmwfact(-0.05)
        end,
        {
           description="decrease master width factor",
           group="layout"
        }
     ),

     -- Increase the number of master clients
     awful.key(
        {modkey, "Shift"}, "h",
        function ()
           awful.tag.incnmaster(1, nil, true)
        end,
        {
           description="increase the number of master clients",
           group="layout"
        }
     ),

     -- Decrease the number of master clients
     awful.key(
        {modkey, "Shift"}, "l",
        function ()
           awful.tag.incnmaster(-1, nil, true)
        end,
        {
           description="decrease the number of master clients",
           group="layout"
        }
     ),


     -- Increase the number of columns
     awful.key(
        {modkey, "Control"}, "h",
        function ()
           awful.tag.incncol(1, nil, true)
        end,
        {
           description="increase the number of columns",
           group="layout"
        }
     ),

     -- Decrease the number of columns
     awful.key(
        {modkey, "Control"}, "l",
        function ()
           awful.tag.incncol(-1, nil, true)
        end,
        {
           description="decrease the number of columns",
           group="layout"

        }
     ),

     -- Select the next window layout
     awful.key(
        {modkey,}, "space",
        function ()
           awful.layout.inc(1)
        end,
            {
               description="select next",
               group="layout"
            }
     ),

     -- Select the previous window layout
     awful.key(
        {modkey, "Shift"}, "space",
        function ()
           awful.layout.inc(-1)
        end,
        {
           description="select previous",
           group="layout"
        }
     ),

     -- Unminimize client
     awful.key(
        {modkey, "Control"}, "n",
        function ()
           local c=awful.client.restore()
           -- Focus restored client
           if c then
              c:emit_signal(
                 "request::activate", "key.unminimize", {raise=true}
              )
           end
        end,
        {
           description="restore minimized",
           group="client"
        }
     ),

     -- -- Run prompt
     -- awful.key(
     --    {modkey}, "r",
     --    function ()
     --       awful.screen.focused().mypromptbox:run()
     --    end,
     --    {
     --       description="run prompt",
     --       group="launcher"
     --    }
     -- ),

    -- Emacs (Super + e followed by KEY)
    awful.key(
       {modkey}, "e",
       function()
          local grabber
          grabber = awful.keygrabber.run(
             function(_, key, event)
                if event == "release" then return end
                if key == "e" then awful.spawn.with_shell(emacs)
                elseif key == "b" then awful.spawn.with_shell(emacs .. "--eval '(ibuffer)'")
                elseif key == "d" then awful.spawn.with_shell(emacs .. "--eval '(dired nil)'")
                elseif key == "s" then awful.spawn.with_shell(emacs .. "--eval '(eshell)'")
                end
                awful.keygrabber.stop(grabber)
             end
          )
       end,
       {
          description = "followed by KEY",
          group = "Emacs"
       }
    ),

     -- -- Run prompt
     awful.key(
        {modkey}, "r",
        function ()
           awful.util.spawn("rofi -show drun")
        end,
        {
           description="run prompt",
           group="launcher"
        }
     ),

     -- Run Lua code
     awful.key(
        {modkey}, "x",
        function ()
           awful.prompt.run {
              prompt = "Run Lua code: ",
              textbox = awful.screen.focused().mypromptbox.widget,
              exe_callback = awful.util.eval,
              history_path = awful.util.get_cache_dir() .. "/history_eval"
           }
        end,
        {
           description="lua execute prompt",
           group="awesome"
        }
     ),

     -- Show the menubar
     awful.key(
        {modkey}, "p",
        function()
           menubar.show()
        end,
        {
           description="show the menubar",
           group="launcher"
        }
     )
  )

  clientkeys = gears.table.join(
     awful.key({modkey,}, "f",
        function (c)
           c.fullscreen = not c.fullscreen
           c:raise()
        end,
        {description="toggle fullscreen", group="client"}),
     awful.key({modkey, "Shift"   }, "c",      function (c) c:kill()                         end,
        {description="close", group="client"}),
     awful.key({modkey, "Control" }, "space",  awful.client.floating.toggle                     ,
        {description="toggle floating", group="client"}),
     awful.key({modkey, "Control" }, "Return", function (c) c:swap(awful.client.getmaster()) end,
        {description="move to master", group="client"}),
     awful.key({modkey,           }, "o",      function (c) c:move_to_screen()               end,
        {description="move to screen", group="client"}),
     awful.key({modkey,           }, "t",      function (c) c.ontop=not c.ontop            end,
        {description="toggle keep on top", group="client"}),
     awful.key({modkey,           }, "n",
        function (c)
           -- The client currently has the input focus, so it cannot be
           -- minimized, since minimized clients can't have the focus.
           c.minimized = true
        end ,
        {description="minimize", group="client"}),
     awful.key({modkey,           }, "m",
        function (c)
           c.maximized = not c.maximized
           c:raise()
        end ,
        {description="(un)maximize", group="client"}),
     awful.key({modkey, "Control" }, "m",
        function (c)
           c.maximized_vertical = not c.maximized_vertical
           c:raise()
        end ,
        {description="(un)maximize vertically", group="client"}),
     awful.key({modkey, "Shift"   }, "m",
        function (c)
           c.maximized_horizontal = not c.maximized_horizontal
           c:raise()
        end ,
        {description="(un)maximize horizontally", group="client"})
  )

  -- Bind all key numbers to tags.
  -- Be careful: we use keycodes to make it work on any keyboard layout.
  -- This should map on the top row of your keyboard, usually 1 to 9.
  for i = 1, 9 do
     globalkeys = gears.table.join(globalkeys,
        -- View tag only.
        awful.key({modkey }, "#" .. i + 9,
           function ()
              local screen = awful.screen.focused()
              local tag = screen.tags[i]
              if tag then
                 tag:view_only()
              end
           end,
           {description = "view tag #"..i, group = "tag"}),
        -- Toggle tag display.
        awful.key({modkey, "Control" }, "#" .. i + 9,
           function ()
              local screen = awful.screen.focused()
              local tag = screen.tags[i]
              if tag then
                 awful.tag.viewtoggle(tag)
              end
           end,
           {description = "toggle tag #" .. i, group = "tag"}),
        -- Move client to tag.
        awful.key({modkey, "Shift" }, "#" .. i + 9,
           function ()
              if client.focus then
                 local tag = client.focus.screen.tags[i]
                 if tag then
                    client.focus:move_to_tag(tag)
                 end
              end
           end,
           {description = "move focused client to tag #"..i, group = "tag"}),
        -- Toggle tag on focused client.
        awful.key({modkey, "Control", "Shift" }, "#" .. i + 9,
           function ()
              if client.focus then
                 local tag = client.focus.screen.tags[i]
                 if tag then
                    client.focus:toggle_tag(tag)
                 end
              end
           end,
           {description = "toggle focused client on tag #" .. i, group = "tag"})
     )
  end

  clientbuttons = gears.table.join(
     awful.button({ }, 1, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
     end),
     awful.button({modkey }, 1, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
        awful.mouse.client.move(c)
     end),
     awful.button({modkey }, 3, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
        awful.mouse.client.resize(c)
     end)
  )

  -- Set keys
  root.keys(globalkeys)

#+end_src

#+RESULTS:

** Rules

#+begin_src lua

  -- Add internal padding to clients
  -- awful.screen.padding(screen[s],10)

  -- Rules to apply to new clients (through the "manage" signal).
  awful.rules.rules = {
     -- All clients will match this rule.
     { rule = { },
        properties = {
           border_width = beautiful.border_width,
           border_color = beautiful.border_normal,
           focus = awful.client.focus.filter,
           raise = true,
           keys = clientkeys,
           buttons = clientbuttons,
           screen = awful.screen.preferred,
           placement = awful.placement.no_overlap+awful.placement.no_offscreen
        }
     },

     -- Floating clients.
     { rule_any = {
        instance = {
           "DTA",  -- Firefox addon DownThemAll.
           "copyq",  -- Includes session name in class.
           "pinentry",
        },
        class = {
           "Arandr",
           "Blueman-manager",
           "Gpick",
           "Kruler",
           "MessageWin",  -- kalarm.
           "Sxiv",
           "Tor Browser", -- Needs a fixed window size to avoid fingerprinting by screen size.
           "Wpa_gui",
           "veromix",
           "xtightvncviewer"},

        -- Note that the name property shown in xprop might be set slightly after creation of the client
        -- and the name shown there might not match defined rules here.
        name = {
           "Event Tester",  -- xev.
        },
        role = {
           "AlarmWindow",  -- Thunderbird's calendar.
           "ConfigManager",  -- Thunderbird's about:config.
           "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
        }
     }, properties = { floating = true }},

     -- Add titlebars to normal clients and dialogs
     { rule_any = {type = { "normal", "dialog" }
     }, properties = { titlebars_enabled = false }
     },

     -- Set Firefox to always map on the tag named "2" on screen 1.
     -- { rule = { class = "Firefox" },
     --   properties = { screen = 1, tag = "2" } },
  }

#+end_src

** Signals

#+begin_src lua

  -- Signal function to execute when a new client appears.
  client.connect_signal("manage", function (c)
     -- Set the windows at the slave,
     -- i.e. put it at the end of others instead of setting it master.
     -- if not awesome.startup then awful.client.setslave(c) end

     if awesome.startup
        and not c.size_hints.user_position
        and not c.size_hints.program_position then
        -- Prevent clients from being unreachable after screen count changes.
        awful.placement.no_offscreen(c)
     end
  end)

  -- Add a titlebar if titlebars_enabled is set to true in the rules.
  client.connect_signal("request::titlebars", function(c)
     -- buttons for the titlebar
     local buttons = gears.table.join(
        awful.button({ }, 1, function()
           c:emit_signal("request::activate", "titlebar", {raise = true})
           awful.mouse.client.move(c)
        end),
        awful.button({ }, 3, function()
           c:emit_signal("request::activate", "titlebar", {raise = true})
           awful.mouse.client.resize(c)
        end)
     )

     awful.titlebar(c) : setup {
        { -- Left
           awful.titlebar.widget.iconwidget(c),
           buttons = buttons,
           layout  = wibox.layout.fixed.horizontal
        },
        { -- Middle
           { -- Title
              align  = "center",
              widget = awful.titlebar.widget.titlewidget(c)
           },
           buttons = buttons,
           layout  = wibox.layout.flex.horizontal
        },
        { -- Right
           awful.titlebar.widget.floatingbutton (c),
           awful.titlebar.widget.maximizedbutton(c),
           awful.titlebar.widget.stickybutton   (c),
           awful.titlebar.widget.ontopbutton    (c),
           awful.titlebar.widget.closebutton    (c),
           layout = wibox.layout.fixed.horizontal()
        },
        layout = wibox.layout.align.horizontal
     }
  end)

  -- Enable sloppy focus, so that focus follows mouse.
  client.connect_signal("mouse::enter", function(c)
     c:emit_signal("request::activate", "mouse_enter", {raise = false})
  end)

  client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
  client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)

#+end_src

** Autostart Applications

#+begin_src lua

  -- Autostart applications
  awful.spawn.with_shell("compton")
  awful.spawn.with_shell("xrandr --output DP-1 --left-of HDMI-0")

#+end_src

** Hotkeys Themeing

#+begin_src lua

  beautiful.hotkeys_bg = beautiful.bg_normal
  beautiful.hotkeys_fg = beautiful.fg_normal
  beautiful.hotkeys_border_width = 10
  beautiful.hotkeys_border_color = beautiful.border_focus
  beautiful.hotkeys_modifiers_fg = beautiful.fg_urgent
  beautiful.hotkeys_label_bg = beautiful.bg_urgent
  beautiful.hotkeys_label_fg = beautiful.bg_focus
  beautiful.hotkeys_font = "Fira Code Retina 10"
  beautiful.hotkeys_description_font = "Fira Code Retina 10"
  beautiful.hotkeys_group_margin = 10

#+end_src

* Theme Configuration

** Dracula Theme
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/awesome/themes/dracula/theme.lua :mkdirp yes 
:END:

This section contains all of the code for the AwesomeWM theme. I am basing my theme off of the [[https://draculatheme.com/][Dracula theme]], so this section of code is gathered into =~/.config/awesome/themes/dracula/theme.lua=.

*Note:* These changes aren't necessarily going to affect the theme used by Awesome. This will only be the case if the function ~beautiful.init(filename)~ is passed the dracula theme file path as an argument in =rc.lua=.

#+begin_src lua

    -- NOTE: This file is automatically updated from changes in the file
    -- ~/.dotfiles/awesome.org. If you wish to make changes to this
    -- theme file, please do so within the awesome.org file!

#+end_src

*** Initialize Classes and Variables

Here we define the things we need to call or build upon in the following code.

#+begin_src lua

  local themes_path = require("gears.filesystem").get_themes_dir()
  local dpi = require("beautiful.xresources").apply_dpi
  local theme = {}
  
#+end_src

*** Basic Theming

In this section, we choose a wallpaper, font, and colors for borders. We can also add gaps to borders via the =useless_gap= class property.

#+begin_src lua

  -- Specify a wallpaper
  theme.wallpaper = "/home/jdylanwhite/.config/awesome/themes/dracula/bg.png"

  -- Specify the font and default size
  theme.font = "Fira Code Retina 11"

  -- Specify colors for frames and system tray, etc.
  theme.fg_normal = "#F8F8F2"
  theme.fg_focus = "#BD93F9"
  theme.fg_urgent = "#50FA7B"
  theme.bg_normal = "#282A36"
  theme.bg_focus = "#44475A"
  theme.bg_urgent = "#FFB86C"
  theme.bg_systray = theme.bg_normal

  -- Specify colors of the borders
  theme.useless_gap = dpi(5)
  theme.border_width = dpi(2)
  theme.border_normal = "#282A36"
  theme.border_focus = "#BD93F9"
  theme.border_marked = "#FF79C6"

#+end_src

*** Menu

Here we can apply some customizations to the menu. The menu is somewhat useful in the early stages of using AwesomeWM, but I'll probably eventually get rid of it. It can be accessed via =Modkey + w= or by right-clicking on the wallpaper.

#+begin_src lua

  -- Set the size of the menu
  theme.menu_height = dpi(25)
  theme.menu_width = dpi(150)

  -- Set the awesome icon and drop down icons
  theme.awesome_icon = themes_path .. "sky/awesome-icon.png"
  theme.menu_submenu_icon = themes_path .. "default/submenu.png"

#+end_src

*** System Tray

#+begin_src lua

  -- Set the icon to appear to specify active clients for a tag
  theme.taglist_squares_sel = themes_path .. "default/taglist/squarefz.png"
  theme.taglist_squares_unsel = themes_path .. "default/taglist/squarez.png"

  -- Add spacing between system tray icons
  theme.systray_icon_spacing = 6

  -- Specify icons to be used for the layout
  theme.layout_tile = themes_path .. "default/layouts/tilew.png"
  theme.layout_tileleft = themes_path .. "default/layouts/tileleftw.png"
  theme.layout_tilebottom = themes_path .. "default/layouts/tilebottomw.png"
  theme.layout_tiletop = themes_path .. "default/layouts/tiletopw.png"
  theme.layout_fairv = themes_path .. "default/layouts/fairvw.png"
  theme.layout_fairh = themes_path .. "default/layouts/fairhw.png"
  theme.layout_spiral = themes_path .. "default/layouts/spiralw.png"
  theme.layout_dwindle = themes_path .. "default/layouts/dwindlew.png"
  theme.layout_max = themes_path .. "default/layouts/maxw.png"
  theme.layout_fullscreen = themes_path .. "default/layouts/fullscreenw.png"
  theme.layout_magnifier = themes_path .. "default/layouts/magnifierw.png"
  theme.layout_floating = themes_path .. "default/layouts/floatingw.png"
  theme.layout_cornernw = themes_path .. "default/layouts/cornernww.png"
  theme.layout_cornerne = themes_path .. "default/layouts/cornernew.png"
  theme.layout_cornersw = themes_path .. "default/layouts/cornersww.png"
  theme.layout_cornerse = themes_path .. "default/layouts/cornersew.png"

  -- Return the theme class
  return theme

#+end_src

** One Theme
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/awesome/themes/one/theme.lua :mkdirp yes
:END:

This section contains all of the code for the AwesomeWM theme. I am basing my theme off of the [[https://onetheme.com/][One theme]], so this section of code is gathered into =~/.config/awesome/themes/one/theme.lua=.

*Note:* These changes aren't necessarily going to affect the theme used by Awesome. This will only be the case if the function ~beautiful.init(filename)~ is passed the one theme file path as an argument in =rc.lua=.

#+begin_src lua

    -- NOTE: This file is automatically updated from changes in the file
    -- ~/.dotfiles/awesome.org. If you wish to make changes to this
    -- theme file, please do so within the awesome.org file!

#+end_src

*** Initialize Classes and Variables

Here we define the things we need to call or build upon in the following code.

#+begin_src lua

  local themes_path = require("gears.filesystem").get_themes_dir()
  local dpi = require("beautiful.xresources").apply_dpi
  local theme = {}

#+end_src

*** Basic Theming

In this section, we choose a wallpaper, font, and colors for borders. We can also add gaps to borders via the =useless_gap= class property.

#+begin_src lua

  -- Specify a wallpaper
  theme.wallpaper = "/home/jdylanwhite/.config/awesome/themes/one/bg.png"

  -- Specify the font and default size
  theme.font = "Fira Code Retina 11"

  -- Specify colors for frames and system tray, etc.
  theme.fg_normal = "#BBC2BF"
  theme.fg_focus = "#51afef"
  theme.fg_urgent = "#C678DD"
  theme.bg_normal = "#282C34"
  theme.bg_focus = "#282C34"
  theme.bg_urgent = "#e06c75"
  theme.bg_systray = theme.bg_normal

  -- Specify colors of the borders
  theme.useless_gap = dpi(5)
  theme.border_width = dpi(2)
  theme.border_normal = "#282C34"
  theme.border_focus = "#51afef"
  theme.border_marked = "#98c379"
  theme.border_urgent = "#e5c07b"
  
#+end_src

*** Menu

Here we can apply some customizations to the menu. The menu is somewhat useful in the early stages of using AwesomeWM, but I'll probably eventually get rid of it. It can be accessed via =Modkey + w= or by right-clicking on the wallpaper.

#+begin_src lua

  -- Set the size of the menu
  theme.menu_height = dpi(25)
  theme.menu_width = dpi(150)

  -- Set the awesome icon and drop down icons
  theme.awesome_icon = themes_path .. "sky/awesome-icon.png"
  theme.menu_submenu_icon = themes_path .. "default/submenu.png"

#+end_src

*** System Tray

#+begin_src lua

  -- Set the icon to appear to specify active clients for a tag
  theme.taglist_squares_sel = themes_path .. "default/taglist/squarefz.png"
  theme.taglist_squares_unsel = themes_path .. "default/taglist/squarez.png"

  -- Add spacing between system tray icons
  theme.systray_icon_spacing = 6

  -- Specify icons to be used for the layout
  theme.layout_tile = themes_path .. "default/layouts/tilew.png"
  theme.layout_tileleft = themes_path .. "default/layouts/tileleftw.png"
  theme.layout_tilebottom = themes_path .. "default/layouts/tilebottomw.png"
  theme.layout_tiletop = themes_path .. "default/layouts/tiletopw.png"
  theme.layout_fairv = themes_path .. "default/layouts/fairvw.png"
  theme.layout_fairh = themes_path .. "default/layouts/fairhw.png"
  theme.layout_spiral = themes_path .. "default/layouts/spiralw.png"
  theme.layout_dwindle = themes_path .. "default/layouts/dwindlew.png"
  theme.layout_max = themes_path .. "default/layouts/maxw.png"
  theme.layout_fullscreen = themes_path .. "default/layouts/fullscreenw.png"
  theme.layout_magnifier = themes_path .. "default/layouts/magnifierw.png"
  theme.layout_floating = themes_path .. "default/layouts/floatingw.png"
  theme.layout_cornernw = themes_path .. "default/layouts/cornernww.png"
  theme.layout_cornerne = themes_path .. "default/layouts/cornernew.png"
  theme.layout_cornersw = themes_path .. "default/layouts/cornersww.png"
  theme.layout_cornerse = themes_path .. "default/layouts/cornersew.png"

  -- Return the theme class
  return theme

#+end_src

** Nord Theme
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/awesome/themes/nord/theme.lua :mkdirp yes
:END:

This section contains all of the code for the AwesomeWM theme. I am basing my theme off of the [[https://nordtheme.com/][Nord theme]], so this section of code is gathered into =~/.config/awesome/themes/nord/theme.lua=.

*Note:* These changes aren't necessarily going to affect the theme used by Awesome. This will only be the case if the function ~beautiful.init(filename)~ is passed the nord theme file path as an argument in =rc.lua=.

#+begin_src lua

    -- NOTE: This file is automatically updated from changes in the file
    -- ~/.dotfiles/awesome.org. If you wish to make changes to this
    -- theme file, please do so within the awesome.org file!

#+end_src

*** Initialize Classes and Variables

Here we define the things we need to call or build upon in the following code.

#+begin_src lua

  local themes_path = require("gears.filesystem").get_themes_dir()
  local dpi = require("beautiful.xresources").apply_dpi
  local theme = {}

#+end_src

*** Basic Theming

In this section, we choose a wallpaper, font, and colors for borders. We can also add gaps to borders via the =useless_gap= class property.

#+begin_src lua

  -- Specify a wallpaper
  theme.wallpaper = "/home/jdylanwhite/.config/awesome/themes/nord/bg.png"

  -- Specify the font and default size
  theme.font = "Fira Code Retina 11"

  -- Specify colors for frames and system tray, etc.
  theme.fg_normal = "#D8DEE9"
  theme.fg_focus = "#81A1C1"
  theme.fg_urgent = "#81A1C1"
  theme.bg_normal = "#233440"
  theme.bg_focus = "#3B4252"
  theme.bg_urgent = "#4C566A"
  theme.bg_systray = theme.bg_normal

  -- Specify colors of the borders
  theme.useless_gap = dpi(5)
  theme.border_width = dpi(2)
  theme.border_normal = "#233440"
  theme.border_focus = "#81A1C1"
  theme.border_marked = "#81A1C1"

#+end_src

*** Menu

Here we can apply some customizations to the menu. The menu is somewhat useful in the early stages of using AwesomeWM, but I'll probably eventually get rid of it. It can be accessed via =Modkey + w= or by right-clicking on the wallpaper.

#+begin_src lua

  -- Set the size of the menu
  theme.menu_height = dpi(25)
  theme.menu_width = dpi(150)

  -- Set the awesome icon and drop down icons
  theme.awesome_icon = themes_path .. "sky/awesome-icon.png"
  theme.menu_submenu_icon = themes_path .. "default/submenu.png"

#+end_src

*** System Tray

#+begin_src lua

  -- Set the icon to appear to specify active clients for a tag
  theme.taglist_squares_sel = themes_path .. "default/taglist/squarefz.png"
  theme.taglist_squares_unsel = themes_path .. "default/taglist/squarez.png"

  -- Add spacing between system tray icons
  theme.systray_icon_spacing = 6

  -- Specify icons to be used for the layout
  theme.layout_tile = themes_path .. "default/layouts/tilew.png"
  theme.layout_tileleft = themes_path .. "default/layouts/tileleftw.png"
  theme.layout_tilebottom = themes_path .. "default/layouts/tilebottomw.png"
  theme.layout_tiletop = themes_path .. "default/layouts/tiletopw.png"
  theme.layout_fairv = themes_path .. "default/layouts/fairvw.png"
  theme.layout_fairh = themes_path .. "default/layouts/fairhw.png"
  theme.layout_spiral = themes_path .. "default/layouts/spiralw.png"
  theme.layout_dwindle = themes_path .. "default/layouts/dwindlew.png"
  theme.layout_max = themes_path .. "default/layouts/maxw.png"
  theme.layout_fullscreen = themes_path .. "default/layouts/fullscreenw.png"
  theme.layout_magnifier = themes_path .. "default/layouts/magnifierw.png"
  theme.layout_floating = themes_path .. "default/layouts/floatingw.png"
  theme.layout_cornernw = themes_path .. "default/layouts/cornernww.png"
  theme.layout_cornerne = themes_path .. "default/layouts/cornernew.png"
  theme.layout_cornersw = themes_path .. "default/layouts/cornersww.png"
  theme.layout_cornerse = themes_path .. "default/layouts/cornersew.png"

  -- Return the theme class
  return theme

#+end_src

** Gruvbox Theme
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/awesome/themes/gruvbox/theme.lua :mkdirp yes 
:END:

This section contains all of the code for the AwesomeWM theme. I am basing my theme off of the [[https://draculatheme.com/][Dracula theme]], so this section of code is gathered into =~/.config/awesome/themes/dracula/theme.lua=.

*Note:* These changes aren't necessarily going to affect the theme used by Awesome. This will only be the case if the function ~beautiful.init(filename)~ is passed the dracula theme file path as an argument in =rc.lua=.

#+begin_src lua

    -- NOTE: This file is automatically updated from changes in the file
    -- ~/.dotfiles/awesome.org. If you wish to make changes to this
    -- theme file, please do so within the awesome.org file!

#+end_src

*** Initialize Classes and Variables

Here we define the things we need to call or build upon in the following code.

#+begin_src lua

  local themes_path = require("gears.filesystem").get_themes_dir()
  local dpi = require("beautiful.xresources").apply_dpi
  local theme = {}
  
#+end_src

*** Basic Theming

In this section, we choose a wallpaper, font, and colors for borders. We can also add gaps to borders via the =useless_gap= class property.

#+begin_src lua

  -- Specify a wallpaper
  theme.wallpaper = "/home/jdylanwhite/.config/awesome/themes/gruvbox/bg.png"

  -- Specify the font and default size
  theme.font = "Fira Code Retina 11"

  -- Specify colors for frames and system tray, etc.
  theme.fg_normal = "#A89984"
  theme.fg_focus = "#D79921"
  theme.fg_urgent = "#CC241D"
  theme.bg_normal = "#282828"
  theme.bg_focus = "#282828"
  theme.bg_urgent = "#689D6A"
  theme.bg_systray = theme.bg_normal

  -- Specify colors of the borders
  theme.useless_gap = dpi(5)
  theme.border_width = dpi(2)
  theme.border_normal = "#282828"
  theme.border_focus = "#98971A"
  theme.border_marked = "#98971A"

#+end_src

*** Menu

Here we can apply some customizations to the menu. The menu is somewhat useful in the early stages of using AwesomeWM, but I'll probably eventually get rid of it. It can be accessed via =Modkey + w= or by right-clicking on the wallpaper.

#+begin_src lua

  -- Set the size of the menu
  theme.menu_height = dpi(25)
  theme.menu_width = dpi(150)

  -- Set the awesome icon and drop down icons
  theme.awesome_icon = themes_path .. "sky/awesome-icon.png"
  theme.menu_submenu_icon = themes_path .. "default/submenu.png"

#+end_src

*** System Tray

#+begin_src lua

  -- Set the icon to appear to specify active clients for a tag
  theme.taglist_squares_sel = themes_path .. "default/taglist/squarefz.png"
  theme.taglist_squares_unsel = themes_path .. "default/taglist/squarez.png"

  -- Add spacing between system tray icons
  theme.systray_icon_spacing = 6

  -- Specify icons to be used for the layout
  theme.layout_tile = themes_path .. "default/layouts/tilew.png"
  theme.layout_tileleft = themes_path .. "default/layouts/tileleftw.png"
  theme.layout_tilebottom = themes_path .. "default/layouts/tilebottomw.png"
  theme.layout_tiletop = themes_path .. "default/layouts/tiletopw.png"
  theme.layout_fairv = themes_path .. "default/layouts/fairvw.png"
  theme.layout_fairh = themes_path .. "default/layouts/fairhw.png"
  theme.layout_spiral = themes_path .. "default/layouts/spiralw.png"
  theme.layout_dwindle = themes_path .. "default/layouts/dwindlew.png"
  theme.layout_max = themes_path .. "default/layouts/maxw.png"
  theme.layout_fullscreen = themes_path .. "default/layouts/fullscreenw.png"
  theme.layout_magnifier = themes_path .. "default/layouts/magnifierw.png"
  theme.layout_floating = themes_path .. "default/layouts/floatingw.png"
  theme.layout_cornernw = themes_path .. "default/layouts/cornernww.png"
  theme.layout_cornerne = themes_path .. "default/layouts/cornernew.png"
  theme.layout_cornersw = themes_path .. "default/layouts/cornersww.png"
  theme.layout_cornerse = themes_path .. "default/layouts/cornersew.png"

  -- Return the theme class
  return theme

#+end_src
